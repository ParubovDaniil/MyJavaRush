Так как же писать хороший и понятный код?

Для этого нужно делать вещи:
Писать хороший и понятный код внутри методов — самое простое.
Решить, какие сущности должны быть в программе
Правильно разбивать программу на логические части
Если код можно улучшить, его нужно улучшить.


В общем, в начале всегда можно руководствоваться принципом:
Программа имеет разные Сущности, а у Сущности есть тип. Вот этот тип — это и есть класс.


У каждого класса есть специальный метод (или методы), которые отвечают за обработку параметров при создании объекта.
Такие методы называются конструкторы. А один метод, соответственно, конструктор.
У него нет типа-результата и его имя совпадает с именем-класса.
Переменные-параметры конструктора имеют те же имена, что и поля класса – x, y.
Это стандартная практика, чтобы не выдумывать названия переменных. Берутся те же имена, что у полей класса, а конфликт имен решается с помощью ключевого слова this.


Когда вы создаете новый объект с помощью оператора new и команды вида «new Класс(параметры)», происходят две вещи:

Java-машина создает объект типа Класс
Java-машина вызывает у объекта конструктор и передает туда ваши параметры


Если у вашего класса вообще нет ни одного конструктора, компилятор добавит вам в класс конструктор-по-умолчанию – конструктор без параметров и кода, но с модификатором public.
Однако, если в вашем классе есть хотя бы один конструктор, конструктор-по-умолчанию уже добавляться не будет – вам нужно будет дописать его самостоятельно.


В Java процесс удаления объектов полностью автоматизирован – удалением объектов занимается сама Java-машина.
Такой процесс называется сборкой мусора (garbage collecting), а механизм, который собирает мусор — сборщиком мусора — Garbage Collector или сокращенно GC.
Все объекты сборщик мусора делит на достижимые и недостижимые. Если на объект есть хотя бы одна ссылка, он считается достижимым.
Если нет ни одной переменной, которая ссылается на объект, такой объект считается недостижимым и объявляется мусором: значит, его можно удалять.

Обязательные проверки при переопределении equals.
public boolean equals(Object obj)
{
   if (this == obj)
      return true;

   if (obj == null)
      return false;

   if (!(obj instanceof Person))
      return false;

Все Java-программисты договорились, что если они пишут свою реализацию метода equals() вместо стандартной (из класса Object),
они также должны написать свою реализацию метода hashCode(), чтобы озвученные выше правила сохранялись.
Такая договоренность называется контрактом.


Все коллекции в Java при поиске элемента внутри коллекции сначала сравнивают hash-code объектов, а только потом вызывают для сравнения метод equals.